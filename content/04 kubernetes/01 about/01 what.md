## 官方定义

Kubernetes 是一个可移植的、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。

Kubernetes 拥有一个庞大且快速增长的生态系统。Kubernetes 的服务、支持和工具广泛可用。

名称 Kubernetes 源于希腊语，意为 "舵手" 或 "飞行员"。

Google 在 2014 年开源了 Kubernetes 项目。
Kubernetes 建立在 Google 在大规模运行生产工作负载方面拥有十几年的经验的基础上，结合了社区中最好的想法和实践。

Google 是最早研发 Linux 容器技术的企业之一，曾公开分享介绍 Google 如何将一切都运行于容器之中。
Google 每周会启用超过 20 亿个容器——全都由内部平台 Borg 支撑。

Borg 是 Kubernetes 的前身，多年来开发 Borg 的经验教训成了影响 Kubernetes 中许多技术的主要因素。

RedHat 是第一批与 Google 合作研发 Kubernetes 的公司之一，作为 Kubernetes 上游项目的第二大贡献者，甚至在这个项目启动之前就已参与其中。

![images](https://70data.oss-cn-beijing.aliyuncs.com/note/20201112144214.svg)

传统部署时代：
组织在物理服务器上运行应用程序。
无法为物理服务器中的应用程序定义资源边界，这会导致资源分配问题。例如，如果在物理服务器上运行多个应用程序，则可能会出现一个应用程序占用大部分资源的情况，结果可能导致其他应用程序的性能下降。
一种解决方案是在不同的物理服务器上运行每个应用程序，但是由于资源利用不足而无法扩展，并且组织维护许多物理服务器的成本很高。

虚拟化部署时代：
作为解决方案，引入了虚拟化功能。
它允许您在单个物理服务器的 CPU 上运行多个虚拟机。每个虚拟机是一台完整的计算机，在虚拟化硬件之上运行所有组件，包括其自己的操作系统。
虚拟化功能允许应用程序在虚拟机之间隔离，并提供安全级别，因为一个应用程序的信息不能被另一应用程序自由地访问。
因为虚拟化可以轻松地添加或更新应用程序、降低硬件成本等等，所以虚拟化可以更好地利用物理服务器中的资源，并可以实现更好的可伸缩性。

容器部署时代：
容器类似于虚拟机，但是它们具有轻量级的隔离属性，可以在应用程序之间共享操作系统。
容器与类似，具有自己的文件系统、CPU、内存、进程空间等。
由于它们与基础架构分离，因此可以跨云和 OS 分发进行移植。

容器因具有许多优势而变得流行起来。

下面列出了容器的一些好处：
- 敏捷应用程序的创建和部署，与使用虚拟机镜像相比，提高了容器镜像创建的简便性和效率。
- 持续开发、集成和部署，通过快速简单的回滚(由于镜像不可变性)，提供可靠且频繁的容器镜像构建和部署。
- 关注开发与运维的分离，在构建/发布时而不是在部署时创建应用程序容器镜像，从而将应用程序与基础架构分离。
- 可观察性不仅可以显示操作系统级别的信息和指标，还可以显示应用程序的运行状况和其他指标信号。
- 跨开发、测试和生产的环境一致性，在便携式计算机上与在云中相同地运行。
- 云和操作系统分发的可移植性，可在 Ubuntu、RHEL、CoreOS、Google Kubernetes Engine 和其他任何地方运行。
- 以应用程序为中心的管理，提高抽象级别，从在虚拟硬件上运行 OS 到使用逻辑资源在 OS 上运行应用程序。
- 松散耦合、分布式、弹性、解放的微服务，应用程序被分解成较小的独立部分，并且可以动态部署和管理，而不是在一台大型单机上整体运行。
- 资源隔离，可预测的应用程序性能。
- 资源利用，高效率和高密度。

### Kubernetes 能做什么

- 服务发现和负载均衡。Kubernetes 可以使用 DNS name 或自己的 IP 地址暴露容器，如果到容器的流量很大，Kubernetes 可以负载均衡并分配网络流量，从而使部署稳定。
- 存储编排。Kubernetes 允许自动挂载选择的存储系统，例如本地存储、公共云提供商等。
- 自动部署和回滚。可以使用 Kubernetes 描述已部署容器的所需状态，它可以以受控的速率将实际状态更改为所需状态。例如，可以自动化 Kubernetes 来为部署创建新容器，删除现有容器并将它们的所有资源用于新容器。
- 自动二进制打包。Kubernetes 允许指定每个容器所需 CPU 和内存。当容器指定了资源请求时，Kubernetes 可以做出更好的决策来管理容器的资源。
- 自我修复。Kubernetes 重新启动失败的容器、替换容器、杀死不响应用户定义的运行状况检查的容器，并且在准备好服务之前不将其通告给客户端。
- 密钥与配置管理。Kubernetes 允许存储和管理敏感信息，例如密码、OAuth 令牌和 ssh 密钥。可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥。

### Kubernetes 不是什么

Kubernetes 不是传统的、包罗万象的 PaaS(平台即服务)系统。

由于 Kubernetes 在容器级别而不是在硬件级别运行，因此它提供了 PaaS 产品共有的一些普遍适用的功能，例如部署、扩展、负载均衡、日志记录和监视。
但是，Kubernetes 不是单一的，默认解决方案是可选和可插拔的。
Kubernetes 提供了构建开发人员平台的基础，但是在重要的地方保留了用户的选择和灵活性。

- Kubernetes 不部署源代码，也不构建您的应用程序。持续集成(CI)、交付和部署（CI/CD）工作流取决于组织的文化和偏好以及技术要求。
- Kubernetes 不指定日志记录、监视或警报解决方案。它提供了一些集成作为概念证明，并提供了收集和导出指标的机制。
- Kubernetes 不提供也不采用任何全面的机器配置、维护、管理或自我修复系统。

## 新解

实际上，Kubernetes 是一个分布式操作系统，它是 Google 在分布式操作系统领域十余年工程经验和智慧的结晶。
而 Google 一直以来都管理着世界上最大的分布式集群，在分布式操作系统领域的研究和认识领先于全世界。

作为分布式操作系统，Kubernetes 的出现远远晚于 UNIX、Linux、Windows 等著名的单机操作系统。
Kubernetes 架构设计自然地继承了很多单机操作系统的珍贵遗产，微内核架构就是这些遗产中最重要的一份。

### UNIX 的兴起

电子计算机诞生之后，在上个世纪 70 年代以前，出现过许许多多的操作系统，DOS、OS/360、Multics 是其中的知名代表，这是操作系统领域的拓荒时代。

20 年来的拓荒孕育出了伟大的成果：
随着 CPU 技术的发展，UNIX 于 1969 年诞生了，这是一个真正意义上的分时操作系统。

借助新的 CPU 技术的支持，UNIX 将软件系统划分为内核(kernel)和用户态程序(userland programs)两部分。
内核是一组中断处理程序的集合，把硬件的能力封装为操作系统功能调用(system calls)。
用户态程序通过系统调用使用硬件功能，用户态程序运行于各自的进程中，所有用户态进程都共享同一个内核。
每当系统调用或中断发生，UNIX 便陷入(trap)内核，内核执行系统调用。
与此同时，内核中的分时调度算法将决定把 CPU 交给哪个进程，并管理进程的上下文切换。
UNIX 还提供了一个特殊的用户态程序 shell，供用户直接使用系统，通过内核提供的进程间通信能力，shell 让用户可以把一系列应用程序组合起来，处理复杂的需求。作者称这个设计思想为 "KISS(Keep It Simple and Stupld)"。

另外，UNIX 几乎把所有硬件都封装为文件。

UNIX 诞生于贝尔实验室，该实验室属于美国国家电信电报公司(AT&T)。
见识到 UNIX 的强大威力之后，AT&T 做出了一个看似无私的决定：将 UNIX 开源，这使得所有现代操作系统得以诞生。
虽然 AT&T 最终被分拆，辉煌不再，但这个决定对人们的贡献绵延至今。
在 21 世纪 20 年代的今天，无论是 MacOS、Windows、Linux，都直接受到 UNIX 的影响，而 iOS 来自 MacOS，Android 来自 Linux，因此 UNIX 的灵魂仍然活在每个人的手机中、活在每个手机 App 后台的服务中。

UNIX 的所有设计思想在当时是都是非常了不起的创举。

UNIX 不但自身对业界产生了巨大的直接贡献，还成为所有现代操作系统的蓝本。
两位作者 Ken Tompson 和 Dennis Ritchie 因此荣获 1983 年度的图灵奖。

UNIX 诞生之时，还附送了一项比操作系统本身价值更大的副产品：
Dennis Ritchie 为开发 UNIX 设计了 C 语言。
C 语言成为了所有流行的现代编程语言的主要设计来源，不仅如此，C 语言在其诞生近 40 年后的今天，仍然是最重要的编程语言之一。

### 微内核的兴起

UNIX 一切皆文件的设计带来了用户程序设计的很多便利，但它要求所有对硬件的封装都要在内核态，因此内核中模块的 bug 会让整个系统受到影响。
比如说，如果某个设备驱动有内存泄漏，所有使用该设备的用户态进程都会有内存泄漏，如果某个内核模块有安全漏洞，整个系统的安全性将不再可控。

为了解决这类问题，上个世纪 70 年代，操作系统研究者们开始发展微内核的概念。
微内核的本质是让操作系统的内核态只保留内存地址管理、线程管理和进程间通讯(IPC)这些基本功能，而把其它功能如文件系统、设备驱动、网络协议栈、GUI 系统等都作为单独的服务，这类服务一般是单独的用户态 daemon 进程。

用户态应用程序通过 IPC 访问这些服务，从而访问操作系统的全部功能。
如此一来，需要陷入内核的系统调用数量将大大减少，系统的模块化更加清晰。
同时系统更加健壮，只有内核中的少量系统调用才有权限访问硬件的全部能力，如设备驱动的问题只会影响对应服务，而不是影响整个系统。

和 micro kernel(微内核) 相对，UNIX 的设计被称为 monolithic kernel。

### 微内核的沉寂

微内核操作系统访问系统服务的效率比 monolithic 操作系统要低得多。

举例而言，在 Linux 中，系统调用(比如 open)只要陷入内核一次，也就是先切换 CPU 到高权限模式，再切回低权限模式。
如果在一个微内核操作系统中，用户调用 open 就需要先拼装一条 IPC 请求消息，发送给对应的文件系统服务进程，随后从文件系统服务进程获取IPC响应消息并解包，拿到调用结果。
这样一来，消息带来的数据拷贝和进程上下文切换都会带来很多开销。消息需要拷贝是因为用户态进程间不能相互访问内存地址，而内核的代码可以访问任何用户态进程的任何内存地址。

正是因为性能原因，OS X 和 Windows 都选择了 hybrid kernel 的架构。

### Kubernetes 和微内核

性能问题对单机操作系统来说可能是至关重要的，但对分布式操作系统并非如此。
分布式操作系统作为幕后功臣，不需要直接面对用户，而单机性能上的小小损失可以用更多机器来弥补，在这个前提下，更好的架构往往更加重要。

##### Borg 的诞生

2003 年，为了更好地支持新版本的搜索引擎，基于 MapReduce，使其能服务好亿万用户，Google 开始了大规模集群管理系统的开发，这个系统叫做 Borg，它的目标是管理以万台为单位的计算机集群。
从操作系统的角度来看，Borg 是一个 monolithic 系统，任何对系统的功能升级都需要深入到 Borg 底层代码来修改支持。

在 2010 年左右，随着 Google 中国部门的撤销，很多优秀的 Google 工程师加入了 BAT 等中国公司，其中一部分加入了腾讯搜搜。
这些前 Googler 加入腾讯后，复刻了 Google 的许多系统，技术上也很出色，其中 Borg 的复制品叫做 TBorg，后来改名为 Torca。
Torca 在搜搜的广告业务中起到了非常重要的作用，后来由于腾讯业务调整，搜搜与搜狗合并，Torca 在腾讯内部失去用户，逐渐停止了维护。

##### Omega 的诞生

在 Borg 上线几年后，Google 意识到 monolithic 架构的问题和瓶颈，于是又一支小团队开始了 Omega 系统的研发。

Omega 系统继承的是微内核的思想，新的功能升级几乎不需修改底层代码就能完成，它比 Borg 更加灵活，有更好的伸缩性。
但因为当时 Google 的全部系统已经搭建在 Borg 之上了，由于 Borg 的 monolithic 特性，MapReduce 等系统都紧密绑定到 Borg 核心代码，不但无缝迁移到 Omega 系统是不可能的，迁移还要花巨大的人力、时间和试错成本。
因此即使核心成员坚持不懈地推动，Omega 系统在 Google 仍未能取得成功。

##### Kubernetes 的诞生

在单机操作系统时代，hybrid kernel 盛行一时，这证明了微内核在软件架构上的成功。
但因为性能问题，又没有任何一个成功的内核采用纯粹的微内核架构，因此微内核从实用角度上来说是失败的。

和单机操作系统时代中微内核架构的失败原因不同，Omega 在 Google 公司内部的失败和性能问题无关，只是历史遗留问题的影响。
对开源社区和大部分公司来说，尚无能和 Borg 相媲美的系统，也没有历史负担。
因此几年后，Google 决定开源 Omega 这一超越 Borg 的新一代分布式操作系统，将其命名为 Kubernetes。

单机操作系统的系统调用需要陷入内核，所谓的陷入(trap)也叫做中断(interrupt)。
无论内核是什么类型，单机操作系统都需要在启动时将系统调用注册到内存中的一个区域里，这个区域叫做中断向量(Interrupt Vector)或中断描述符表(IDT，Interrupt Descriptor Table)。

当然，现代操作系统的中断处理非常复杂，系统调用也很多。
因此除了 IDT 之外，还需要一张系统调用表(SCV，System Call Vector)。
系统调用通过一个统一的中断入口调用某个中断处理程序，由这个中断处理程序通过 SCV 把系统调用分发给内核中不同的函数代码。因此 SCV 在操作系统中的位置非常重要。
对微内核架构来说，除了 SCV 中的系统调用之外，用户态服务提供什么样的系统能力，同样需要注册到某个区域。

与此类似，Kubernetes 这样的分布式操作系统对外提供服务是通过 API 的形式。
分布式操作系统本身提供的 API 相当于单机操作系统的系统调用，每个 API 也需要能够注册到某个位置。

对 Kubernetes 来说，API 会注册到 ectd 里。
Kubernetes 本身提供的相当于系统调用的那些 API，通过名为 Controller 的组件来支持。
由开发者为 Kubernetes 提供的新的 API，则通过 Operator 来支持。
Operator 本身和 Controller 基于同一套机制开发。
这和微内核架构的思想一脉相承：Controller 相当于内核态中运行的服务，提供线程、进程管理和调度算法等核心能力，Operator 则相当于微内核架构中 GUI、文件系统、打印机等服务，在用户态运行。

因此，Kubernetes 的工作机制和单机操作系统也较为相似。
etcd 提供一个 watch 机制，Controller 和 Operator 需要指定自己 watch 哪些内容，并告诉 etcd，这相当于是微内核架构在 IDT 或 SCV 中注册系统调用的过程。

当然，Kubernetes 和单机操作系统也有不同之处：
Kubernetes 没有明确的陷入过程，而微内核架构的单机操作系统在访问系统调用时需要陷入，在访问用户态服务时则不需要陷入。
但是，Kubernetes 可以为不同的服务设置不同的权限，这一点在一定程度上类似于单机操作系统中内核态和用户态的 CPU 权限的区别。

微内核在架构上的优势在 Kubernetes 中显露无遗：
在 Borg 中，开发者想要添加新的子系统是非常复杂的，往往需要修改 Borg 底层代码，而新系统也因此会绑定到 Borg 上。
而对 Kubernetes 来说，开发者只需要基于 Kubernetes 提供的 SDK 实现一个 Operator，就能够添加一组新的 API，而不需要关注 Kubernetes 的底层代码。

任何已有软件都可以方便地通过 Operator 机制集成到 Kubernetes 中，因而 Kubernetes 非常适合作为公有云的底层分布式操作系统。
正因如此，Kubernetes 在 2014 年年中发布，经过 2015 年一年的成长，在 2016 年便成为业界主流。
对于没有历史负担的公司，也将 Kubernetes 作为内部云的底层系统使用。

### 尾声

总的来说，显著超前于时代的技术虽然未必能在被提出的时代取得成功。
但一定会在多年后，在时代跟上来之后，拿回属于自己的荣耀。

微内核架构在单机操作系统的时代和云计算的时代的不同遭遇证明了这一点，深度学习在低算力时代和高算力时代的不同遭遇也证明了这一点。

值得一提的是，在 Kubernetes 之后，Google 推出了 Fuchsia 作为 Android 可能的替代品。
而 Fuchsia 基于 Zircon 内核开发，Zircon 基于 C++ 开发，正是微内核架构。

在算力井喷的现代，除了在分布式操作系统领域，微内核能否也在手机/物联网操作系统领域复兴，拭目以待。

